top的s列表示的是进程状态
R：正在运行或等待运行
D：disk sleep，不可中断状态睡眠，表示进程正在与硬件交互，并且交互过程不允许打断
Z：zombie，僵尸进程，父亲不负责，导致问题少年
S: Interrupttible Sleep,可中断状态睡眠，表示进程因为等待某个事件而被系统挂起。当等待的事件发生时，会被唤醒进入R
I：Idle，空闲状态，不可中断睡眠的内核线程上，硬件交互导致的用D，但某些实际上没有任何负载，用I来区分这种情况。D会导致负载升高，I不会。

T或t，表示进程处于暂停或跟踪状态
X：表示进程消亡，一般不会看到。

1.iowait升高的原因（大量D进程）
一般iowait升高，可能的原因是i/o问题
a.用dstat 命令同时查看cpu和i/o对比情况（如 dstat 1 10 间隔1秒输出10组数据），通过结果可以发现iowait升高时，磁盘读请求（read）升高
所以推断iowait升高是磁盘读导致
b.定位磁盘读的进程，使用top命令查看处于不可中断状态（D）的进程PID
c.查看对应进程的磁盘读写情况，使用pidstat命令，加上-d参数，可以看到i/o使用情况（如 pidstat -d -p <pid> 1 3）,
发现处于不可中断状态的进程都没有进行磁盘读写
d.继续使用pidstat命令，但是去掉进程号，查看所有进程的i/o情况（pidstat -d 1 20），可以定位到进行磁盘读写的进程。
我们知道进程访问磁盘，需要使用系统调用，
下面的重点就是找到该进程的系统调用
e.使用strace查看进程的系统调用 strace -p <pid>
发现报了 strace:attach :ptrace(PTRACE_SIZE，6028)：Operation not peritted,说没有权限，我是使用的root权限，所以这个时候就要查看进程的状态是否正常
f.ps aux | grep <pid> 发现进程处于Z状态，已经变成了僵尸进程，所以不能进行系统调用分析了
g.既然top和pidstat都不能找出问题，使用基于事件记录的动态追踪工具,如perf

2.僵尸进程
僵尸进程出现的原因是父进程没有回收子进程的资源出现的。解决办法是找到父进程，在父进程中处理，
使用pstree查父进程，然后查看父进程的源码检查wait()/waitpid()的调用或SIGCHLD信号处理函数的注册。
